<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Prix spot vs ARENH — série mensuelle (€/MWh)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --pn-text:#0b0f19; --pn-muted:#64748b;
      --pn-spot:#5A52FF; --pn-arenh:#334155;
      --pn-grid:rgba(0,0,0,0.03);
    }
    body{
      margin:0; background:#fff;
      font-family:'Inter',system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      display:flex; justify-content:center; padding:40px 16px;
    }
    .chart-wrapper{ width:100%; max-width:1200px; }
    h1{ margin:0 0 10px; text-align:center; font-size:22px; font-weight:600; color:var(--pn-text); }
    .legend-note{ margin:0 0 12px; text-align:center; color:var(--pn-muted); font-size:13px; }
    canvas{ width:100% !important; height:auto !important; }
    .err{ margin-top:10px; text-align:center; color:#ef4444 }
  </style>
</head>
<body>
  <div class="chart-wrapper">
    <h1>Évolution du prix spot de l'électricité en France</h1>
    <div class="legend-note">Unité : <strong>€/MWh</strong></div>
    <canvas id="chart"></canvas>
  </div>

  <script>
  const CSV_URL = "https://raw.githubusercontent.com/FEPPN/graph_prix_spot/main/data_prix_spot.csv";

  const parseNumberSmart = s => Number(String(s ?? '').trim().replace(/\s+/g,'').replace(',', '.'));
  function detectSep(h){ const t=(h.match(/\t/g)||[]).length,s=(h.match(/;/g)||[]).length,c=(h.match(/,/g)||[]).length; if(t>0)return'\t'; if(s>=c)return';'; return','; }
  const FR_MONTHS = {"janv.":1,"févr.":2,"mars":3,"avr.":4,"mai":5,"juin":6,"juil.":7,"août":8,"sept.":9,"oct.":10,"nov.":11,"déc.":12};
  const toSortKey = ym => { const p=String(ym).trim().split(/\s+/); const m=FR_MONTHS[(p[0]||'').toLowerCase()], y=Number(p[1]); return (!m||!Number.isFinite(y))?ym:`${y}-${String(m).padStart(2,'0')}`; };

  fetch(CSV_URL + "?v=" + Date.now(), { cache:'no-store' })
    .then(r => { if(!r.ok) throw new Error(`Impossible de charger le CSV (HTTP ${r.status})`); return r.text(); })
    .then(text => {
      text = text.replace(/^\uFEFF/, '');
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (lines.length <= 1) throw new Error("CSV vide");

      const sep = detectSep(lines[0]);
      const header = lines[0].split(sep).map(h => h.trim().toLowerCase());
      const idxYM    = header.findIndex(h => /year[_\s-]*month|mois|p[eé]riode/.test(h));
      const idxSpot  = header.findIndex(h => /prix.*mwh|mwh.*prix|spot/.test(h));
      if (idxYM < 0 || idxSpot < 0) throw new Error("Colonnes attendues introuvables");

      const rows=[];
      for(let i=1;i<lines.length;i++){
        const cols=lines[i].split(sep);
        const ym=(cols[idxYM]??"").trim(); if(!ym) continue;
        const spot=parseNumberSmart(cols[idxSpot]);
        rows.push({ label: ym, sortKey: toSortKey(ym), spot: Number.isFinite(spot)?spot:null });
      }
      rows.sort((a,b)=>(a.sortKey+'').localeCompare(b.sortKey+''));

      const labels   = rows.map(r=>r.label);
      const spotVals = rows.map(r => (r.sortKey >= "2017-01") ? r.spot : null);
      const arenhFlat = labels.map(_ => 42);

      // Trouver index de cassure (conservé si besoin plus tard)
      let breakIndex = -1;
      for(let i=0; i<rows.length-1; i++){
        if(rows[i].sortKey === "2012-01" && rows[i+1].sortKey === "2017-01"){
          breakIndex = i;
          break;
        }
      }

      // X ticks: 2011, 2012, puis Janvier à partir de 2017
      const showTick = new Set();
      rows.forEach(r=>{
        if (r.sortKey === "2011-01" || r.sortKey === "2012-01") showTick.add(r.label);
        if (r.sortKey >= "2017-01") {
          const m = Number((r.sortKey||"").slice(5,7));
          if (m === 1) showTick.add(r.label);
        }
      });

      drawChart({labels, spotVals, arenhFlat, showTick, breakIndex});
    })
    .catch(err => {
      console.error(err);
      document.querySelector('.chart-wrapper')
        .insertAdjacentHTML('beforeend', `<p class="err">Erreur : ${err.message}</p>`);
    });

  function drawChart({labels, spotVals, arenhFlat, showTick, breakIndex}){
    const ctx=document.getElementById('chart').getContext('2d');
    const grad=ctx.createLinearGradient(0,0,0,300);
    grad.addColorStop(0,"rgba(90,82,255,0.20)");
    grad.addColorStop(1,"rgba(90,82,255,0.00)");

    const chart = new Chart(ctx,{
      type:'line',
      data:{
        labels,
        datasets:[
          {
            label:"Prix spot (€/MWh)",
            data:spotVals,
            borderColor:"#5A52FF",
            backgroundColor:grad,
            borderWidth:1.8,
            pointRadius:0,
            tension:0.25,
            fill:true,
            spanGaps:false
          },
          {
            label:"ARENH (€/MWh)",
            data:arenhFlat,
            borderColor:"#334155",
            backgroundColor:"transparent",
            borderWidth:1.6,
            pointRadius:0,
            tension:0,
            fill:false,
            borderDash:[6,4]
          }
        ]
      },
      options:{
        responsive:true,
        maintainAspectRatio: true,
        interaction:{ mode:'nearest', intersect:false },
        plugins:{
          legend:{
            position:"bottom",
            labels:{ color:"#1f2937", font:{ size:13, weight:"600" } }
          },
          tooltip:{
            backgroundColor:"#fff", borderColor:"#e5e7eb", borderWidth:1,
            titleColor:"#111827", bodyColor:"#4b5563",
            titleFont:{weight:'700'}, bodyFont:{weight:'500'},
            padding:10, cornerRadius:10,
            callbacks:{
              label:(ctx)=>{
                const v=ctx.parsed.y;
                if(!Number.isFinite(v)) return;
                return `${ctx.dataset.label} : ${v.toFixed(2)} €/MWh`;
              }
            }
          }
        },
        scales: {
          y: {
            min: 0,
            ticks: { 
              color:"#6b7280", 
              callback: v => `${Number(v).toFixed(0)}` 
            },
            grid: { color: "rgba(0,0,0,0.06)", lineWidth: 1 },
            border:{ display:false }
          },
          x: {
            offset:true,
            ticks: {
              color:"#6b7280",
              maxRotation:45,
              autoSkip:false,
              maxTicksLimit:50,
              callback:(val, idx)=> showTick.has(labels[idx]) ? labels[idx] : '',
              font: { size: 11 }
            },
            grid: { display:false },
            border: { display:false }
          }
        }
      },
      plugins: [{
        id: 'customAnnotations',
        afterDatasetsDraw(chartInstance) {
          const ctx = chartInstance.ctx;
          const xScale = chartInstance.scales.x;
          const yScale = chartInstance.scales.y;
          const area = chartInstance.chartArea;

          // utilitaires
          const clamp = (v, min, max) => Math.max(min, Math.min(max, v));

          // indices des mois
          const idx2011 = labels.indexOf('janv. 2011');
          const idx2012 = labels.indexOf('janv. 2012');

          if (idx2011 >= 0) {
            const x2011 = xScale.getPixelForValue(idx2011);
            const y2011 = yScale.getPixelForValue(41);

            // position de la bulle (à gauche, dans le cadre)
            let labelX = x2011 - 52;
            let labelY = y2011 - 48;
            labelX = clamp(labelX, area.left + 22, area.right - 22);
            labelY = clamp(labelY, area.top + 18, area.bottom - 24);

            // bulle "41"
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(labelX - 18, labelY - 12, 36, 24, 6);
            else { ctx.rect(labelX - 18, labelY - 12, 36, 24); }
            ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#334155';
            ctx.font = '600 12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('41', labelX, labelY);
            ctx.restore();

            // flèche **verticale** (perpendiculaire à l’axe X)
            drawArrow(ctx, x2011, labelY + 12, x2011, y2011 - 2, '#334155');
          }

          if (idx2012 >= 0) {
            const x2012 = xScale.getPixelForValue(idx2012);
            const y2012 = yScale.getPixelForValue(42);

            // position de la bulle (à droite, dans le cadre)
            let labelX = x2012 + 52;
            let labelY = y2012 - 48;
            labelX = clamp(labelX, area.left + 22, area.right - 22);
            labelY = clamp(labelY, area.top + 18, area.bottom - 24);

            // bulle "42"
            ctx.save();
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            if (ctx.roundRect) ctx.roundRect(labelX - 18, labelY - 12, 36, 24, 6);
            else { ctx.rect(labelX - 18, labelY - 12, 36, 24); }
            ctx.fill(); ctx.stroke();

            ctx.fillStyle = '#334155';
            ctx.font = '600 12px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('42', labelX, labelY);
            ctx.restore();

            // flèche diagonale vers le point
            drawArrow(ctx, labelX - 18, labelY + 12, x2012, y2012 - 2, '#334155');
          }
        }
      }]
    });

    // Fonction pour dessiner une flèche
    function drawArrow(ctx, fromX, fromY, toX, toY, color) {
      const headlen = 6;
      const angle = Math.atan2(toY - fromY, toX - fromX);
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle = color;
      ctx.lineWidth = 1.5;

      // segment
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();

      // pointe
      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }
  </script>
</body>
</html>
